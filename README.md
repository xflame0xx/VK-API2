# 1) Call Stack и Event Loop

**Что это такое и как связаны**

- **Call Stack (стек вызовов)** — структура данных (LIFO), где JS-движок держит контекст выполняемых функций. Когда вызывается функция — она «кладётся» в стек; когда завершилась — «снимается».
- **Event Loop (цикл событий)** — механизм, который координирует выполнение отложенных задач: берёт их из очередей и передаёт в Call Stack, когда стек пуст.

**Связь простая**: всё реально исполняется в Call Stack, а Event Loop решает, когда добавить туда следующую задачу из очередей.

---

**С какими видами задач они работают**

Упрощённо выделяют:

- **Синхронный код** — выполняется сразу, напрямую в Call Stack.
- **Macrotasks (таски)** — очередь «task queue»:
  - `setTimeout`, `setInterval`
  - события DOM (`click`, `input`)
  - `MessageChannel`, `postMessage`
  - (в браузере) некоторые I/O
- **Microtasks (микротаски)** — очередь `microtask queue`:
  - `Promise.then/catch/finally`
  - `queueMicrotask`
  - `MutationObserver` (в браузере)

**Ключевое правило**: после выполнения каждой macrotask event loop “дренирует” (полностью) очередь microtasks, и только затем берёт следующую macrotask.

---

**Пример задач и порядок обработки**

```js
console.log("A");

setTimeout(() => console.log("T"), 0);          // macrotask
Promise.resolve().then(() => console.log("P")); // microtask

console.log("B");
```

**Порядок:**

- `A` (sync)
- `B` (sync)
- `P` (microtask — выполняется сразу после завершения текущего синхронного кода)
- `T` (macrotask — уже на следующем «тике»)

**Итого вывод**: `A B P T`.

---

# 2) Promise

**Определение и зачем нужен**

- **Promise** — объект-обёртка над асинхронным результатом, который будет доступен в будущем: либо успешно (`value`), либо с ошибкой (`reason`).

**Зачем нужен:**
- упрощает асинхронный код по сравнению с «callback hell»
- даёт стандартизированные способы композиции (`then`, `catch`, `finally`, `all`, …)
- является основой `async/await`

---

**Где встречается в JS**

- практически везде, где есть асинхронность:
  - `fetch()` возвращает Promise
  - многие Web API и современные библиотеки
  - пользовательские `async`-функции (`async function` всегда возвращает Promise)

---

**Состояния и работа через `then`/`catch`**

**Состояния:**
- `pending` — Ожидание
- `fulfilled` — выполнен успешно
- `rejected` — завершён с ошибкой

**Работа:**
- `then(onFulfilled)` — обработка успеха, возвращает новый Promise
- `catch(onRejected)` — обработка ошибки, эквивалентно `then(null, onRejected)`
- `finally(onFinally)` — выполнится в любом случае (без изменения `value`/`reason`, если вы его не бросаете заново)

**Пример:**
```js
doSomething()
  .then(result => transform(result))
  .then(finalValue => console.log(finalValue))
  .catch(err => console.error("Ошибка:", err))
  .finally(() => console.log("Завершено"));
```

---

**Что делают `all`, `race`, `any`, `allSettled`**

- `Promise.all(iterable)`
  - ждёт все успешно.
  - resolve: массив результатов в исходном порядке
  - reject: сразу при первой ошибке

- `Promise.race(iterable)`
  - завершается по первому завершившемуся (и success, и error).

- `Promise.any(iterable)`
  - ждёт первый успешный.
  - resolve: первый `fulfilled`
  - reject: если все `rejected` → `AggregateError`

- `Promise.allSettled(iterable)`
  - ждёт все, никогда не падает «раньше времени».
  - Возвращает массив объектов вида:
    ```js
    { status: "fulfilled", value: ... }
    { status: "rejected", reason: ... }
    ```

---

# 3) Что такое `fetch`, зачем нужен и какие `options` у него есть

**`fetch`** — браузерный (и в современных средах часто платформенный) API для выполнения HTTP-запросов. Возвращает Promise, который резолвится в `Response`.

**Зачем нужен:**
- получение/отправка данных на сервер (REST, GraphQL и т.п.)
- замена старого `XMLHttpRequest` более современным интерфейсом

**Пример:**
```js
const res = await fetch("/api/users", { method: "GET" });
const data = await res.json();
```

**Часто используемые `options`:**
- `method`: `"GET" | "POST" | "PUT" | "PATCH" | "DELETE" | ...`
- `headers`: объект или `Headers` (например `Authorization`, `Content-Type`)
- `body`: тело запроса (строка, `FormData`, `Blob`, `URLSearchParams` и т.д.) — обычно для `POST`/`PUT`/`PATCH`
- `mode`: `"cors" | "no-cors" | "same-origin"` (в браузере)
- `credentials`: `"omit" | "same-origin" | "include"` (куки/авторизация)
- `cache`: `"default" | "no-store" | "reload" | ...`
- `redirect`: `"follow" | "error" | "manual"`
- `signal`: `AbortController.signal` для отмены запроса
- `referrer`, `referrerPolicy`, `integrity`, `keepalive` (реже, но встречается)

**Важный нюанс**: `fetch` не делает `reject` на HTTP 4xx/5xx, Promise успешно резолвится, но `res.ok === false`. Ошибки сети/отмены — это `reject`.

---

# 4) DRY, KISS, S.O.L.I.D. + примеры

**DRY (Don’t Repeat Yourself)**  
Не дублируй логику. Повторяющийся код вынести в функцию/модуль.

**Плохо:**
```js
const totalA = itemsA.reduce((s, x) => s + x.price, 0);
const totalB = itemsB.reduce((s, x) => s + x.price, 0);
```

**Лучше:**
```js
const calcTotal = items => items.reduce((s, x) => s + x.price, 0);
```

---

**KISS (Keep It Simple, Stupid)**  
Делай решение максимально простым и читаемым, без преждевременной «архитектуры».

**Плохо**: сложные абстракции ради одной страницы.  
**Лучше**: простая функция/хук/утилита, пока требования не усложнились.

---

**SOLID (в контексте JS/TS, ООП и модульности)**

- **S — Single Responsibility (одна ответственность)**  
  Модуль/класс делает одну вещь.  
  Пример: `UserRepository` только про доступ к данным, `UserService` — бизнес-логика.

- **O — Open/Closed (открыт для расширения, закрыт для изменения)**  
  Добавляем поведение через расширение, не переписывая существующий код.  
  Пример: стратегия валидации: добавили новую функцию-валидатор, не меняя обработчик формы.

- **L — Liskov Substitution (подстановка Барбары Лисков)**  
  Наследник должен корректно заменять базовый тип без поломки ожиданий.  
  В JS чаще проявляется как: «не ломай контракт интерфейса/типа», особенно в TS.

- **I — Interface Segregation (разделение интерфейсов)**  
  Лучше несколько маленьких контрактов, чем один огромный.  
  Пример: не заставлять объект реализовывать методы, которые ему не нужны; делить типы/интерфейсы.

- **D — Dependency Inversion (инверсия зависимостей)**  
  Зависеть от абстракций, а не от конкретики.  
  Пример: сервис принимает `httpClient` как зависимость (инъекция), а не импортирует конкретный `fetch` напрямую — это упрощает тестирование.

**Мини-пример (D + S):**
```js
export class ApiClient {
  constructor(http) { this.http = http; } // абстракция: любой клиент с .request
  getUsers() { return this.http.request("/users"); }
}
```
# 5) Какие два хранилища предоставляет Web Storage API? Методы и особенности

**Два хранилища:**

- **`localStorage`**  
  Постоянное хранилище, данные сохраняются даже после закрытия браузера и перезагрузки устройства.

- **`sessionStorage`**  
  Временное хранилище, привязанное к конкретной вкладке браузера и её сессии.

**Общие методы (одинаковый интерфейс `Storage`):**

- `getItem(key)` → `string | null`  
  Возвращает значение по указанному ключу или `null`, если ключ не существует.

- `setItem(key, value)` (значение хранится как строка)  
  Сохраняет пару ключ-значение; если ключ уже существует, его значение перезаписывается.

- `removeItem(key)`  
  Удаляет значение по указанному ключу, если оно существует.

- `clear()`  
  Удаляет все пары ключ-значение из хранилища.

- `key(index)` → `key | null`  
  Возвращает имя ключа по его числовому индексу (порядок не гарантируется) или `null`, если индекс выходит за пределы.

- `length` (кол-во ключей)  
  Свойство, возвращающее количество сохранённых ключей в хранилище.

**Особенности:**

- Хранит только строки. Для объектов: `JSON.stringify` / `JSON.parse`.  
- Синхронный API. Большие объёмы данных могут блокировать main thread.  
- Same-origin policy. Доступно только в рамках одного origin (протокол+хост+порт).

**Различия:**

- **`localStorage`**: данные сохраняются «долго» (пока не очистят вручную/кодом/политикой браузера).  
- **`sessionStorage`**: живёт в рамках вкладки (tab) и сессии; закрыли вкладку — данные пропали. При этом у разных вкладок одного сайта — разные `sessionStorage`.

**Событие:**

- `storage` event (в браузере) срабатывает при изменениях storage в других вкладках/окнах того же origin (не в том же документе, который сделал `setItem`).

